def JENKIN_GIT_CREDENTIALS_ID = "8c90ce01-4736-4b5a-8661-ab6299330151"
def JENKIN_K8S_CREDENTIALS_ID = 'kubernetes-gucci-dev'
def INFORM_ABOUT_FAILURE = 'grp.hfhs@sytoss.com'
def JENKINS_NODE_JS_INSTALLATION_LABEL = 'node10.16.3'

def proposal_version = ""
def overview = "Version proposal"
def ver_list = ""
def release_version = ""
def base_build = null
def sanity_test_job_name = "hfhs-release-sanity-test"

/* 
Variable 'projects' contains list of widgets that can be released.
*/

def widgets = [
    "microfrontend-hfhs-createaccount": "",
    "microfrontend-hfhs-bulk-operation" : "",
    "microfrontend-hfhs-processing" : "",
    "microfrontend-hfhs-changeownership" : "",
    "microfrontend-hfhs-product-details" : "",
    "microfrontend-hfhs-business-transaction-detail" : "",
    "microfrontend-hfhs-business-transaction-history" : "",
    "microfrontend-hfhs-toolbar" : "",
    "microfrontend-hfhs-product-move" : "",
    "microfrontend-hfhs-search-product" : "",
];

def modules = [
    "microfrontend-hfhs-base" : "",
    "microfrontend-hfhs-connector" : ""
]

def projects = widgets + modules

Boolean isVersionValid(String version){
    String regex = /\d+\.{1}\d+\.{1}\d+/
    if (version ==~ regex) return true
    else return false
}

Boolean isReleaseNeeded(String version){
    String prerelease_regex = /\d+\.{1}\d+\.{1}\d+\-.*/
    if ((version ==~ prerelease_regex) || (version == "" )) return true
    else return false
}

String releaseDecision(String version){
    if (isReleaseNeeded(version) == true ) return """Release needed ( ${version} )"""
    else return """Release NOT needed ( ${version} )"""
}

void setComponentVersion(String package_name, String package_version){
    def package_data = readJSON file: 'package.json'
    if(package_data.'dependencies'.containsKey(package_name)){
        package_data.'dependencies'."${package_name}" = "^" + package_version 
    }
    writeJSON file: 'package.json', json: package_data, pretty: 2
}

String getMostRecentVersion(String version_list){
    def mod_version_list = "\'" + version_list + "\'"
    return sh(returnStdout: true, script: "printf ${mod_version_list} | sort -V | tail -1").trim()
}

Boolean isTagExist(String version){
    def tag = '\'refs/tags/' + 'v' + version + '\''
    def grep_statement = '\'^' + tag + '\$\''
    def tag_count = sh(returnStdout: true, script: "git ls-remote -q --tags | awk '{print \$2}'| grep ${grep_statement} | wc -l").trim().toInteger()
    if(tag_count > 0) return true
    else return false
}

String getComponentVersion(String component_name){
    def package_data = readJSON file: 'package.json'
    return package_data.'dependencies'."${component_name}"?: ""
}

String getPackageAttribute(String attr){
    def package_data = readJSON file: 'package.json'
    return package_data."${attr}"
}

void checkPackageProperties(Boolean isRelease, String packageName, String packageVersion, Map projects){
    overview = packageName + " versions in package.json\n    "
    def isBaseVerValid = true
    if (isRelease == false){
        projects.each{ k,v ->
            if (k == packageName) return
                dir(k + "/") {
                    def full_name = "@a1/" + packageName
                    def component_version = (getComponentVersion(full_name)).replaceAll("[@^=]+","")
                    isBaseVerValid = isBaseVerValid && (isVersionValid(component_version) || (component_version  == ""))
                    overview = overview + k + ": " + component_version + "\n    "
                }
            }
        echo "${overview}"
        if (isBaseVerValid == false) {
            error("Some widgets has wrong version. Release build will be interrupted.")
        }
    }
    else{
        echo "Now will be set recent version of ${packageName} in 'package.json' of widgets"
        projects.each{ k,v ->
            dir(k + "/"){
                def set_version = ComponentVersion(packageName, packageVersion)
                sh "${set_version}"
                sh "git add package.json || true"
            }
        }
    }
}

Boolean isPluggableModule(String packageName){
    if ((packageName == "microfrontend-hfhs-base") || (packageName == "microfrontend-hfhs-connector")) return true
    else return false
}

String reportWidgetStatus(String widget_name, String widget_version, String release_version){
    def name = widget_name
    def prev_version = widget_version
    def curr_version = widget_version
    def highlight = ""
    if (widget_version == ""){
        highlight = 'bgcolor="#61f14d"'
        prev_version = "-"
        curr_version = release_version
    }
    else{
        if (isReleaseNeeded(widget_version) == true) {
            highlight = 'bgcolor="#f5e629"'
            curr_version = release_version
        }
    }
    def row = """
    <tr ${highlight}><td>${name}</td><td>${prev_version}</td><td>${curr_version}</td></tr>
    """
    return row
}

String report(Map projects, String release_version){
    def widget_status = ""
    projects.each { k,v ->
        widget_status = widget_status + "\n" + reportWidgetStatus(k,v,release_version)
    }
    Date date = new Date()
    String datePart = date.format("dd.MM.yyyy")
    String timePart = date.format("HH:mm")

    def build_time = timePart + " " + datePart
    def sheet = """
    <!DOCTYPE html><html lang="en" dir="ltr"><head><meta charset="utf-8">
<title>HFHS Release ${release_version}</title></head><body 
style="font-family:system-ui,sans-serif;"><h1 align="center">
HFHS release report</h1><div class="body"><table border="0" 
width="100%"><tr><td width="10%"></td><td><p>Congratulations!<br>
HFHS release version ${release_version} has been done successfully. Here is the list of widgets:
<br></p><p><table width="100%" border="0"><tr><th width="50%">Name
</th><th>Previous version</th><th>Current version</th></tr>
${widget_status}</table></p></td><td width="10%"></td></tr></table>
</div><div class="footer"><hr><p 
style="font-size: 8pt; text-align:center">
This report was generated automatically at ${build_time}</p></div>
</body></html>
    """
    return sheet
}

String widgetResolution(String widget_name, String widget_version){
    def resolution = releaseDecision(widget_version)
    return """    ${widget_name}: ${resolution}"""
}

String releaseOverview(String release_version, Map projects){
    def widget_status = ""
    projects.each { k,v ->
        widget_status = widget_status + "\n" + widgetResolution(k,v)
    }
    def sheet = """
Recommended version: ${release_version}
${widget_status}
"""
return sheet
}

def templatedSubstageCheckProperties = {isRelease,name,version,project_list ->
    return{
        stage("Check properties"){
            checkPackageProperties(isRelease,name,version,project_list)
        }
    }
}

def templatedSubstagePrepare = {name ->
    return{
        stage("Install dependencies"){
            dir("${name}/"){
                sh 'git status'
                nodejs(JENKINS_NODE_JS_INSTALLATION_LABEL) {
                    sh 'npm i'
                }
            }
        }
    }
}
def templatedSubstageBuild = {name,version ->
    return{
        stage("Build"){
            dir("${name}/"){
                sh 'git status'
                nodejs(JENKINS_NODE_JS_INSTALLATION_LABEL) {
                    sh 'npm run build'
                    sh 'git checkout package-lock.json || true'
                    sh "npm version ${base_build['baseVersion']} --force"
                }
            }
        }
    }
}

def templatedSubstagePush = {name ->
    return{
        stage("Push tags and artifacts"){
            dir("${name}/"){
                sh 'git status'
                withCredentials([usernamePassword(credentialsId: JENKIN_GIT_CREDENTIALS_ID, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
                    sh "git push https://${USERNAME}:${PASSWORD}@tasktrack.telekom.at/bitbucket/scm/ccf/${name}.git"
                    sh "git push https://${USERNAME}:${PASSWORD}@tasktrack.telekom.at/bitbucket/scm/ccf/${name}.git --tags"
                    nodejs(JENKINS_NODE_JS_INSTALLATION_LABEL) {
                        sh "npm-cli-adduser --registry https://tasktrack.telekom.at/artifactory/api/npm/npm-repos --username ${USERNAME}  --password ${PASSWORD} --email ${USERNAME}@a1.at --scope @a1"
                        sh "npm publish"
                    }
                }
            }
        }
    }
}

def templatedWidgetSubstagePush = {name ->
    return{
        stage("Push tags and artifacts"){
            dir("${name}/"){
                sh 'git status'
                withCredentials([usernamePassword(credentialsId: JENKIN_GIT_CREDENTIALS_ID, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
                    sh "git push https://${USERNAME}:${PASSWORD}@tasktrack.telekom.at/bitbucket/scm/ccf/${name}.git"
                    sh "git push https://${USERNAME}:${PASSWORD}@tasktrack.telekom.at/bitbucket/scm/ccf/${name}.git --tags"
                    nodejs(JENKINS_NODE_JS_INSTALLATION_LABEL) {
                        sh "npm-cli-adduser --registry https://tasktrack.telekom.at/artifactory/api/npm/npm-repos --username ${USERNAME}  --password ${PASSWORD} --email ${USERNAME}@a1.at --scope @a1"
                        sh "npm publish"
                        sh "npm run docker-push-image"
                    }
                }
            }
        }
    }
}

def moduleTemplatedStage = { project_dir,release_variable,version,project_list ->
    stage_name = "Module: ${project_dir}"
    if(base_build[release_variable] == true && base_build['baseVersion']  ==~ /\d+\.{1}\d+\.{1}\d+/){
        return{
            stage(stage_name){
                templatedSubstageCheckProperties(base_build[release_variable],project_dir,version,project_list).call()
                templatedSubstagePrepare(project_dir).call()
                templatedSubstageBuild(project_dir,version).call()
                templatedSubstagePush(project_dir).call()
            }
        }
    }
    else{
        return{
            stage(stage_name){
                templatedSubstageCheckProperties(base_build[release_variable],project_dir,version,project_list).call()
            }
        }
    }
}

def widgetTemplatedStage = {project_dir,version ->
    stage_name = "Widget: ${project_dir}"
    return{
        stage(stage_name){
            templatedSubstagePrepare(project_dir).call()
            templatedSubstageBuild(project_dir,version).call()
            templatedWidgetSubstagePush(project_dir).call()
        }
    }
}


pipeline{
    agent{
        node{
            label null
        }
    }
    options{
        disableConcurrentBuilds()
        parallelsAlwaysFailFast()
    }
    stages{
        stage("Preparation steps"){
            stages{
                stage('Clone repos'){
                    steps{
                        deleteDir()
                        withCredentials([usernamePassword(credentialsId: JENKIN_GIT_CREDENTIALS_ID, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]){
                            sh "docker login -u ${USERNAME} -p ${PASSWORD} tasktrack.telekom.at/gucci-docker-local"
                            script{
                                projects.each {k,v ->
                                    sh "git clone -b develop --single-branch https://${USERNAME}:${PASSWORD}@tasktrack.telekom.at/bitbucket/scm/ccf/${k}.git"
                                }
                            }
                        }
                    }

                }
                stage('Get versions of widgets'){
                    steps{
                        script{
                            projects.each { k,v ->
                                dir(k + "/") {
                                    sh 'git checkout develop && git status'
                                    raw_version = sh(returnStdout: true, script: 'git describe --tags | cut -c 2-').trim()
                                    projects[k] = raw_version
                                    ver_list = ver_list + raw_version.split("-")[0] + "\\n"
                                } 
                            }
                            proposal_version = getMostRecentVersion(ver_list)
                            echo "${releaseOverview(proposal_version, projects)}"
                            release_version = proposal_version
                        }
                    }
                }
                stage('Prerelease check'){
                    steps{
                        script{
                            base_build = input(
                                id: 'base_build', message: 'HFHS Release',
                                parameters: [
                                    booleanParam(defaultValue: isReleaseNeeded(projects.find{it.key == "microfrontend-hfhs-base" }?.value),
                                                 description: "Make release of Base",
                                                 name: 'isBaseRelease'),
                                    booleanParam(defaultValue: isReleaseNeeded(projects.find{it.key == "microfrontend-hfhs-connector" }?.value),
                                                 description: "Make release of HFHS Connector",
                                                 name: 'isConnectorRelease'),
                                    string(defaultValue: "$release_version",
                                           description: 'with version',
                                           name: 'baseVersion'),
                                ])
                            if (!(base_build['baseVersion']  ==~ /\d+\.{1}\d+\.{1}\d+/)){
                                error("Inappropriate version number. Release build will be interrupted.")
                            }
                            echo "Check chosen tag existance"
                            def notValidTag = 0
                            projects.each{ k,v ->
                                if(isReleaseNeeded(projects.find{it.key == k }?.value) == false) return
                                dir(k + "/"){
                                    if(isTagExist(base_build['baseVersion']) == true){
                                        echo "${k} already have tag ${base_build['baseVersion']}"
                                        notValidTag += 1
                                    }
                                }
                            }
                            if (notValidTag > 0 ){
                                error("Some projects already have tag ${base_build['baseVersion']}. Release build will be interrupted.")
                            }
                        }
                    }
                }
            }
        }
        stage("Build modules"){
            steps{
                script{
                    moduleTemplatedStage("microfrontend-hfhs-base","isBaseRelease",base_build['baseVersion'],projects).call()
                    moduleTemplatedStage("microfrontend-hfhs-connector","isConnectorRelease",base_build['baseVersion'],projects).call()
                }
            }
        }
        stage("Build widgets"){
            steps{
                script{
                    widgets.each{k,v ->
                        if(isReleaseNeeded(projects.find{it.key == k }?.value) == false) return
                        widgetTemplatedStage(k,base_build['baseVersion']).call()
                    }
                }
            }
        }
        stage("Deploy widgets to INT"){
            environment {
                NODE_ENV = 'integration'
                NAMESPACE = 'gucci-int'
                REPLICA_COUNT = '1'
            }
            steps{
                script{
                    projects.each{ k,v ->
                        if ((isReleaseNeeded(projects.find{it.key == k}?.value) == false) || (isPluggableModule(k) == true)) return
                        dir(k + "/") {
                            env.IMAGE_VERSION = getPackageAttribute("version")
                            echo "Deploying ${k}:${env.IMAGE_VERSION} to INT"
                            withKubeConfig([credentialsId: JENKIN_K8S_CREDENTIALS_ID]) {
                                sh 'envsubst < kubernetes/deployment.yml | kubectl apply -v=6 -f -'
                                sh 'envsubst < kubernetes/service.yml | kubectl apply -v=6 -f -'
                            }
                        }
                    }
                }
            }
        }
        stage("Perform sanity tests"){
            steps{
                build job: sanity_test_job_name,  propagate: false, quietPeriod: 150
            }
        }
    }
    post{
        success{
            script{
                widgets.each{ k,v ->
                    sh "docker rmi \$(docker images tasktrack.telekom.at/gucci-docker-local/${k}:latest | tail -n +2 | awk '{print \$3}') -f || true"
                }
            }
            emailext to: INFORM_ABOUT_FAILURE,
                     subject: "${JOB_NAME} for version ${base_build['baseVersion']} has been finished",
                     body: report(projects, base_build['baseVersion']),
                     attachLog: false,
                     mimeType: 'text/html'
        }
        failure {
            emailext to: INFORM_ABOUT_FAILURE,
                     subject: "${JOB_NAME} for version ${base_build['baseVersion']} has been failed",
                     body: "Please go to ${BUILD_URL} and verify the build",
                     attachLog: true
        }
    }
}